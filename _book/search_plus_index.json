{"./":{"url":"./","title":"Introduction","keywords":"","body":"Java核心快速入门 var gitalk = new Gitalk({ clientID: 'ea29097a2b9bf811f1db', // GitHub Application Client ID clientSecret: 'cdf360ca85cf7193dc4faa9467adf8c4068d9049', // GitHub Application Client Secret repo: 'blog-comments', // 存放评论的仓库 owner: 'shixiuyin', // 仓库的创建者， admin: ['shixiuyin','hzittest'], // 如果仓库有多个人可以操作，那么在这里以数组形式写出 id: location.pathname, // 用于标记评论是哪个页面的，确保唯一，并且长度小于50 }); gitalk.render('gitalk-container'); // 渲染Gitalk评论组件 powered by Gitbook该文件最后修改时间： 2019-08-23 13:47:23 "},"content/mybatis/mybatis01入门简介.html":{"url":"content/mybatis/mybatis01入门简介.html","title":"入门简介","keywords":"","body":"mybatis_day01 一、简介 1.概述 ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github ​ MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。ORM框架(Hibernate也是orm框架)，MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。 ​ MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录； 2.作用 -MyBatis 是一个ORM框架 对象关系映射（Object Relational Mapping），是一个半自动化的ORM框架, (Hibernate也是全自动化的orm框架)： –易于学习，几乎消除了所有的JDBC代码； –原生sql存在Xml文件中，便于管理； –解除sql与程序代码的耦合； –支持对象关系映射； –支持编写动态sql，比如一些条件查询； –对JDBC进行封装。 3.架构 1、 mybatis配置 SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。 mapper.xml文件即sql映射文件，配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 2、 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 3、 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 4、 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是 缓存执行器。 5、 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml 文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 6、 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设 置参数。 7、 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 4.下载使用 mybaits的代码由github.com管理， 地址：https://github.com/mybatis/mybatis-3/releases 二、入门程序 基本步骤: 1.创建项目导入相关的jar包（核心包，依赖包，数据库驱动包） 2.创建mybatis核心的xml配置文件 3.单个的sqlmapper的xml文件，必须被核心文件加载 4.创建pojo的java对象和sql语句 5.测试程序 1.步骤一 创建项目，并导入相关的jar包 mybaits核心包； 数据库启动包; org.mybatis mybatis 3.2.7 mysql mysql-connector-java 5.1.39 junit junit 4.12 test 2.步骤二 在resources目录下创建mybaits核心配置文件。 SqlMapConfig.xml 注：重点关注\\的type属性、其有三种取值： POOLED：使用Mybatis自带的数据库连接池来管理数据库连接 UNPOOLED：不使用任何数据库连接池来管理数据库连接 JNDI：jndi形式使用数据库连接、主要用于项目正常使用的时候 3.步骤三 创建对应的mapper文件，用来存放对应的sql语句 a.创建Users.xml文件 namespace ：命名空间(可以理解为java中package包，用来区分对象)，用于隔离sql语句 在Users.xml中添加：半自动化，自己主要负责的是具体的sql的编写，添加到mapper中 b.编写对应的sql语句 select * from users select * from users where userid = #{userid} select * from users where userName like '%${value}%' parameterType：定义输入(参数类型)到sql中的映射类型， #{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。 resultType：定义结果(返回值)映射类型。 c.将Users.xml添加SqlMapConfig.xml mybatis框架需要加载映射文件，将Users.xml添加在SqlMapConfig.xml，如下： 该节点放在\\节点后面，和该节点是同辈节点。 4.步骤四 a.sql语句 CREATE TABLE `users` ( `userId` int(11) NOT NULL AUTO_INCREMENT, `userName` varchar(255) DEFAULT NULL, `userPwd` varchar(255) DEFAULT NULL, `userAge` int(11) DEFAULT NULL, `userSex` varchar(255) DEFAULT NULL, `userAddr` varchar(255) DEFAULT NULL, PRIMARY KEY (`userId`) ) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8; b.实体类 public class Users { pricom.hzit.bean.Usersvate Integer userId;// ID数据库自增 private String userName; private String userPwd; private Integer userAge; private String userSex; private String addr; //get and set } 5.步骤五 测试 @Test public void test1() throws Exception { // 会话工厂 SqlSessionFactory sqlSessionFactory = null; // 配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 Users user = sqlSession.selectOne(\"test.findUserById\", 3); // 输出用户信息 System.out.println(user); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 输出结果: Users [userId=3, userName=小花, userPwd=123, userAge=12, userSex=m, addr=null] 常见参数 #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值。 自动进行java类型和jdbc类型转换； #{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。p ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值， 如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。 selectOne:查询一条记录，如果使用selectOne查询多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList:可以查询一条或多条记录。 三、操作数据 1.为了方便演示使用junit进行测试。首先第一步需要导入junit相对应的jar包。上面已经导入 2.mybaits所有的操作都需要得到SqlSession对象。 SqlSession sqlSession = null; //全局变量 @Before public void init() throws Exception { // 会话工厂 SqlSessionFactory sqlSessionFactory = null; // 配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); } @Before注解，表示每次@Test 之前都会调用该方法，这么表示每次都会去创建 sqlSession，所有后面可以直接使用 1.删除数据 a.在UserMapper.xml中添加sql语句： delete from Users where userid = #{userid} b.测试类 //删除 @Test public void test01() { //test.deleteUsersById 调用对应sql 13:实参 int row = sqlSession.delete(\"test.deleteUsersById\", 13); System.out.println(row); sqlSession.commit();// 增删改需要提交事务 } 2.修改数据 a.sql语句 update Users set userName=#{userName},userPwd=#{userPwd},userAge=#{userAge},userSex=# {userSex},userAddr=#{addr} where userId=#{userId} b.测试语句 // 修改 @Test public void test02() { // 可以去获取一个对象 也可以new一个新对象 Users users = sqlSession.selectOne(\"test.findUserById\", 4); System.out.println(\"修改之前:\" + users); // 修改 users.setUserName(\"赵子龙他哥\"); sqlSession.update(\"test.updateUser\", users); sqlSession.commit(); Users newUser = sqlSession.selectOne(\"test.findUserById\", 4); System.out.println(\"修改之后:\" + newUser); } c.结果 修改之前:Users [userId=4, userName=赵子龙, userPwd=123, userAge=88, userSex=m, addr=null] 修改之后:Users [userId=4, userName=赵子龙他哥, userPwd=123, userAge=88, userSex=m, addr=null] 3.添加数据 3.1普通添加(不考虑主键) a.sql语句 insert into Users values(#{userId},#{userName},#{userPwd},#{userAge},#{userSex},#{addr}) b.测试 // 添加1 @Test public void test03() { Users users = new Users(); users.setUserId(1001); users.setUserName(\"来耍\"); users.setUserPwd(\"123\"); users.setUserSex(\"m\"); users.setUserAge(20); users.setAddr(\"广东深圳\"); int row = sqlSession.insert(\"test.addUser\", users); System.out.println(row); sqlSession.commit(); } c.结果 3.2使用数据库自增主键 a.sql语句 insert into Users(userName,userPwd,userAge,userSex,userAddr) values(#{userName},#{userPwd},#{userAge},#{userSex},#{addr}) b.测试 @Test public void test04() { Users users = new Users(); users.setUserName(\"旺财\"); users.setUserPwd(\"123\"); users.setUserSex(\"m\"); users.setUserAge(20); users.setAddr(\"广东深圳\"); int row = sqlSession.insert(\"test.addUserByKey\", users); System.out.println(row); sqlSession.commit(); } 3.3使用程序自增主键 a.sql语句 SELECT LAST_INSERT_ID() insert into Users(userId,userName,userPwd,userAge,userSex,userAddr) values(#{userId},#{userName},#{userPwd},#{userAge},#{userSex},#{addr}) b.测试 @Test public void test05() { Users users = new Users(); users.setUserName(\"赵大锤\"); users.setUserPwd(\"123\"); users.setUserSex(\"m\"); users.setUserAge(20); users.setAddr(\"广东深圳\"); int row = sqlSession.insert(\"test.addUserByGenKey\", users); System.out.println(row); sqlSession.commit(); } 3.4相关参数 SelectKey在Mybatis中为了解决Insert数据时不支持主键自动生成的问题，他可以随意的设置生成主键的方式 属性 描述 keyProperty selectKey 语句结果应该被设置的目标属性 resultType 结果的类型。MyBatis 通常可以算出来,但是写上也没有.MyBatis 允许任何简单类型用作主键的类型,包括字符串 statementType 和前面的相 同,MyBatis 支持 STATEMENT ,PREPARED 和CALLABLE 语句的映射类型,分别代表 PreparedStatement 和CallableStatement 类型 SelectKey 需要注意order属性，像Mysql一类支持自动增长类型的数据库中，order需要设置为after才会取到正确的值。 像Oracle这样取序列的情况，需要设置为before，否则会报错 > 四、log4j日志文件 Mybatis使用log4j作为默认的日志。可以在项目中添加log4j信息 a. 第一步导入相应的log4j需要的jar包信息 log4j log4j 1.2.17 b. 第二步，创建log4j.properties配置文件， 注意：名称不能改变，必须log4j.properties ​ 必须放在resource目录下面 log4j.properties配置文件信息： # Global logging configuration 开发时候建议使用 debug log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n powered by Gitbook该文件最后修改时间： 2019-08-24 15:36:20 "},"content/mybatis/mybatis02配置文件详解.html":{"url":"content/mybatis/mybatis02配置文件详解.html","title":"配置文件详解","keywords":"","body":"一、配置文件详解 1.SqlMapConfig.xml配置文件 1.1properties（属性） SqlMapConfig.xml可以引用java属性文件中的配置信息如下,在resource下定义db.properties文件. jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/bj1801?useUnicode=true&characterEncoding=utf8 jdbc.username=root jdbc.password=root 以上定义了文件内容，可以直接在配置文件中进行引用。 SqlMapConfig.xml引用如下： 1.2settings（配置） mybatis全局配置参数，全局参数将会影响mybatis的运行行为。 1.3typeAliases（类型别名） 可以设置单个类，或者包的别名。设置完之后可以直接使用别名，代替全路径。在SqlMapConfig.xml中配置： 1.4mappers（映射器） Mapper配置的几种方法： a.resource方式\\ 使用相对于类路径的资源 如： b.url方式\\ 使用完全限定路径 如： c.class方式\\ 使用mapper接口类路径 如： 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 d.package 方式\\ 注册指定包下的所有mapper接口 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 2.xxxMapper.xml配置文件 SQL 映射文件结构： -cache - 配置给定命名空间的缓存。 -cache-ref – 从其他命名空间引用缓存配置。 -resultMap – 最复杂，也是最有力量的元素，用来描述如何从数据库结果集中来加载对象。 (重点) -sql – 可以重用的 SQL 块，也可以被其他语句引用。 -insert – 映射插入语句 -update – 映射更新语句 -delete – 映射删除语句 -select – 映射查询语- 2.1Select中的属性 属性 描述 id 在命名空间中唯一的标识符，可以被用于引用 该语句。 parameterType 将会传入该语句的参数类的完全限定名或别名。 resultType 从该语句中返回的期望类型的类的完全限定名 或别名。 resultMap 命名引用外部的resultMap。 flushCache 将其设置为true，无论语句什么时候被调用， 都会导致缓存被清空。默认值为false useCache 将其设置为true，将会导致本条语句的结果 被缓存。默认值为true。 timeout 该设置驱动程序等待数据库返回请求结果。 fetchSize 暗示驱动程序每次批量返回的结果行数。 默认不设置（驱动自行处理） statementType STATEMENT、PREPARED或CALLABLE的 一种 resultSetType FORWARD_ONLY\\ SCROLL_SENSITIVE\\ SCROLL_INSENSITIVE中的一种。默认不设置 （驱动自行处理）。 2.2 insert、update和delete 属性 描述 id 在命名空间中唯一的标识符，可以被用于引用该语句。 parameterType 将会传入该语句的参数类的完全限定名或别名。 flushCache 将其设置为true，无论语句什么时候被调用，都会 导致缓存被清空。默认值为false。 timeout 该设置驱动程序等待数据库返回请求结果，并抛出 异常时间的最大等待值。默认不设置（驱动自行处理）。 statementType STATEMENT、PREPARED或CALLABLE的一种。 用于方便MyBatis选择使用Statement、 PreparedStatement或CallableStatement。 默认值为PREPARED useGeneratedKeys （仅对insert有用）通知MyBatis使用JDBC的 getGeneratedKeys方法来取出由数据（如MySQL 和SQL Server的数据库管理系统的自动递增字段） 内部生成的主键。默认值为false。 keyProperty （仅对insert有用）标记一个属性，MyBatis会通过 getGeneratedKeys或insert语句的selectKey子元素设 置其值。默认不设置。 2.3sql片段 可以将XXXMapper.xml文件中的共性部分抽取出来。然后进行引用。 deptno,dname,loc select from dept 2.4resultMap(明天讲) powered by Gitbook该文件最后修改时间： 2019-08-24 15:37:05 "},"content/mybatis/mybatis03Mapper动态代理开发.html":{"url":"content/mybatis/mybatis03Mapper动态代理开发.html","title":"Mapper动态代理开发","keywords":"","body":"一、dao层Mapper动态代理开发 以上是通过手动的去调用对应的方法，例如selectOne(),selectList()等等。这种方式需要自己去实现代码。 Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象 Mapper接口开发需要遵循以下规范： 1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。 2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 4.1定义dao层接口 public interface UsersMapper { public Users findUserByid(int uid); public List findUserList(); public List findUserByUsername(String uname); public int addUsers(Users users); public int updateUser(Users users); } 4.2定义对应sql语句 select uId,uName,uPwd,phone uPhone,address from users where uId=#{uId} select * from users select * from users where uName like '%${value}%' insert into users(uName,uPwd,phone,address) values(#{uName},#{uPwd},#{uPhone},#{address}) 4.3测试代码 public static void main(String[] args) throws Exception { // 会话工厂 SqlSessionFactory sqlSessionFactory = null; // 配置文件 String resource = \"SqlMapConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = null; sqlSession = sqlSessionFactory.openSession(true); // 获取 mapper代理对象 UsersMapp mapper = sqlSession.getMapper(UsersMapp.class); System.out.println(\">>>获取所有信息\"); List userList = mapper.findUserList(); System.out.println(userList); System.out.println(\">>>通过ID获取信息\"); Users users = mapper.finUserByid(105); System.out.println(users); System.out.println(\">>>通过uName模糊查询\"); List findUserByUsername = mapper.findUserByUsername(\"zhang\"); System.out.println(findUserByUsername); System.out.println(\">>>添加数据,ID自动增长\"); Users users2 = new Users(); users2.setuName(\"hello\"); users2.setuPwd(\"8888\"); users2.setuPhone(\"1881123\"); users2.setAddress(\"china\"); int addUsers = mapper.addUsers(users2); System.out.println(addUsers); } 以上代码必须符号以上四种规则，否则会报错。 powered by Gitbook该文件最后修改时间： 2019-08-24 15:37:53 "},"content/mybatis/mybatis04动态sql.html":{"url":"content/mybatis/mybatis04动态sql.html","title":"动态sql","keywords":"","body":"一、动态sql MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 if choose (when, otherwise) trim (where, set) foreach 1.1 if标签 select * from user where 1=1 and id=#{id} and username like '%${username}%' 注意要做不等于空字符串校验。 1.2 Where标签 上边的sql也可以改为： select * from user and id=#{id} andusername like '%${username}%' \\可以自动处理第一个and。 1.3 Set标签 set元素可以被用于动态包含需要更新的列，而舍去其他的。比如： update Author username=#{username}, password=#{password}, email=#{email}, bio=#{bio} where id=#{id} 1.4 choose, when, otherwise ​ 有时我们不想应用到所有的条件语句，而只想从中择其一项。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 SELECT * FROM BLOG WHERE state = ‘ACTIVE’ AND title like #{title} AND author_name like #{author.name} AND featured = 1 1.5 foreach 动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候 标签相关属性: index：为数组的下标。 item：为数组每个元素的名称，名称随意定义 open：循环开始 close：循环结束 separator：中间分隔输出 1.5.1通过pojo传递list 在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法 0\"> #{id} 1.5.2传递单个List 传递List类型在编写mapper.xml没有区别，唯一不同的是只有一个List参数时它的参数名为list。 select * from user #{item.id} public List selectUserByList(List userlist) throws Exception; 1.5.3传递单个数组（数组中是pojo) sql只接收一个数组参数，这时sql解析参数的名称mybatis固定为array，如果数组是通过一个pojo传递到sql则参数的名称为pojo中的属性名。 select * from user #{item.id} public List selectUserByArray(Object[] userlist) throws Exception; powered by Gitbook该文件最后修改时间： 2019-08-24 15:38:17 "},"content/mybatis/mybatis05对应关系.html":{"url":"content/mybatis/mybatis05对应关系.html","title":"对应关系","keywords":"","body":"一、对应关系 一对一查询 案例：查询所有宠物信息，并查询出对应的主人信息。 注意：因为宠物只属于一个主人，所以从宠物信息出发关联主人信息为一，因为一个宠物信息只属于一个主人。所以是一对一关系；相反的如果从主人信息出发，那就是一对多了，因为一个主人可以拥有多个宠物。 方法一： 使用resultType，定义宠物信息实体类，此实体类包含了宠物信息，主人信息 1.1定义PetMsg实体类 实体类具体的字段，如下： public class PetMsg extends Pet { private int ownerId; private String ownerName; //get set.... } PetMsg继承了Pet宠物信息类，包含了所有的宠物信息，所以只需要定义主人需要的信息即可。 1.2Mapper.xml 1.3Mapper接口： 1.4测试: 1.5总结： 定义专门的实体类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 方法二： 使用resultMap，定义专门的resultMap用于映射一对一查询结果。 1.1定义实体类 ​ 在Pet类中加入petOwner属性，petOwner属性中用于存储关联查询的主人信息，因为宠物查询主人是一对一关系，所以这里使用单个PetOwner对象存储关联查询的主人信息。 1.2Mapper.xml 1.3定义resultMap 需要关联查询映射的是用户信息，使用association将主人信息映射到宠物对象的petOwner属性中。 association：表示进行关联查询单条记录 property：表示关联查询的结果存储在com.hzit.bean.Pet的petOwner属性中 javaType：表示关联查询的结果类型 1.4 mapper接口： 1.5 测试： 1.6小结： 使用association完成关联查询，将关联查询信息映射到实体对象中 一对多查询 案例：查询宠物对应类型下的宠物信息 宠物类型（PetType）与宠物信息(Pet)为一对多关系。 使用resultMap实现如下： 1.定义实体类 在PetType类中加入petList属性。 2.Mapper.xml 3.定义resultMap collection部分定义了查询订单明细信息。 collection：表示关联查询结果集 property=\"petlist\"**：关联查询的结果集存储在com.hzit.bean.PetType上哪个属性。 ofType=\"com.hzit.bean.Pet \"**：指定关联查询的结果集中的对象类型即List中的对象类型。 及的意义同一对一查询。 4.Mapper接口： 5.测试： 6.resultMap小结 resultType： 作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。 resultMap： 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。 association：作用： 将关联查询信息映射到一个pojo对象中。 使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用 resultType还是resultMap。 collection：作用：将关联查询信息映射到一个list集合中。 场合： 为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中。 powered by Gitbook该文件最后修改时间： 2019-08-24 15:38:46 "},"content/mybatis/mybatis06缓存.html":{"url":"content/mybatis/mybatis06缓存.html","title":"缓存","keywords":"","body":"一、缓存 mybatis提供了缓存机制减轻数据库压力，提高数据库性能 mybatis的缓存分为两级：一级缓存、二级缓存 Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。 1.一级缓存 一级缓存默认开启的，所以可以直接使用. /** * 一级缓存 */ @Test public void test01() { //使用同一个 openSession1 即可 SqlSession openSession1 = sqlSessionFactory.openSession(); UsersMapper usersMapper = openSession1.getMapper(UsersMapper.class); Users users = usersMapper.findUserByid(1001); System.out.println(users); UsersMapper usersMapper2 = openSession1.getMapper(UsersMapper.class); Users users2 = usersMapper2.findUserByid(1001); System.out.println(users2); } 2.二级缓存 默认不开启二级缓存，需要自己去手动开启； 二级缓存是针对整个mapper下所有的语句 主要步骤: a.实体类需要序列化 实体类必须实现Serializable接口 public class Users implements Serializable{} b.设置核心配置文件 SqlMapConfig.xml c.设置XXXMapper文件 二级 d.测试 @Test public void test02() { SqlSession openSession1 = sqlSessionFactory.openSession(); SqlSession openSession2 = sqlSessionFactory.openSession(); SqlSession openSession3 = sqlSessionFactory.openSession(); UsersMapper usersMapper = openSession1.getMapper(UsersMapper.class); Users users = usersMapper.findUserByid(1001); System.out.println(users); openSession1.commit(); //提交 才会往缓存中 存数据 //users.setUserName(\"小花\"); //UsersMapper usersMapper3 = openSession3.getMapper(UsersMapper.class); //usersMapper3.updateUser(users); //openSession3.commit(); UsersMapper usersMapper2 = openSession2.getMapper(UsersMapper.class); Users users2 = usersMapper2.findUserByid(1001); System.out.println(users2); } 测试结果: 两次查询，但是只打印了一次sql,第二次直接从缓存中获取 DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6acdbdf5] DEBUG [main] - ==> Preparing: select * from users where userid = ? DEBUG [main] - ==> Parameters: 1001(Integer) DEBUG [main] - powered by Gitbook该文件最后修改时间： 2019-08-24 15:39:14 "}}